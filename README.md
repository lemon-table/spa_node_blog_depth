# Node.js 심화 주차 개인과제  

## 환경변수
- DATABASE_URL : MySQL의 데이터베이스 URL
- JWT_SECRET_KEY : JWT에 사용되는 비밀키  

## API 명세서 URL  

- https://docs.google.com/spreadsheets/d/1BzT0aK6L-2N2G31iBUWfO3Vd_Mo28cQ5_ixjp9xCZlc/edit?usp=sharing  

## ERD URL  

- https://www.erdcloud.com/p/bofSR3pGYpSEGnv5M  

## 더 고민해 보기  

1. **Class와 Instance가 각각 무엇인지 설명해 주세요**
- Class(클래스)
클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위한 일종의 설계 도면이나 틀입니다. 클래스는 속성(멤버 변수)와 행동(메서드)을 정의하며, 이를 통해 객체의 특징과 동작을 결정합니다. 클래스는 추상적인 개념으로, 실제로 메모리에 할당되는 것이 아니라 객체를 생성하기 위한 틀로 사용됩니다.
- Instance(인스턴스)
인스턴스는 클래스를 기반으로 실제로 메모리에 할당되어 생성된 객체를 말합니다. 클래스는 설계도이지만, 이 설계도를 기반으로 실체가 만들어진 것이 인스턴스입니다. 각 인스턴스는 클래스에서 정의한 속성을 가지며, 클래스에서 정의한 행동(메서드)을 수행할 수 있습니다.
- 간단히 말하면, 클래스는 객체를 만들기 위한 틀이고, 인스턴스는 그 틀을 이용해 만들어진 실제 객체를 의미합니다.  

2. **Class의 Method는 화살표 함수(Arrow Function) 형태로 구현하지 않았을 때 발생할 수 있는 문제와 해당 문제를 해결할 수 있는 다른 방법을 적어주세요.**
- Class의 Method를 화살표 함수(Arrow Function) 형태로 구현하지 않을 경우, 발생할 수 있는 주요 문제 중 하나는 this의 바인딩입니다.
- 화살표 함수는 자신만의 this를 생성하지 않고, 외부 스코프의 this를 그대로 사용합니다. 클래스 메서드 내에서 화살표 함수를 사용하면 해당 메서드 내에서의 this는 클래스의 인스턴스가 아닌, 외부 스코프에 따라 달라질 수 있습니다.
- 해결방법으로는 세가지를 들 수 있습니다.
- 1) bind 메서드 사용: bind 메서드를 사용하여 메서드를 현재 인스턴스에 바인딩하여 새로운 함수를 생성할 수 있습니다.
  2) 화살표 함수 대신 일반 함수 사용:화살표 함수 대신 일반 함수를 사용하면 자동으로 외부 스코프의 this가 유지됩니다.
  3) 클래스 프로퍼티 문법 사용: 클래스 프로퍼티 문법을 사용하면 메서드를 화살표 함수로 정의할 수 있고, bind나 function 키워드를 사용하지 않아도 됩니다.  

3. **3-Layered Architecture의 장점과 단점을 아는대로 적어주세요.**
- 3-Layered Architecture는 소프트웨어 시스템을 세 가지 주요 레이어로 나누어 구성하는 아키텍처 디자인 패턴입니다. 각 레이어는 특정한 역할을 수행하며, 시스템을 모듈화하여 유지보수, 확장, 테스트를 쉽게 만들어줍니다.
- 장점
- 1) 모듈화와 재사용성: 각 레이어가 엄격하게 분리되어 있기 때문에 특정 레이어의 변경이 다른 레이어에 미치는 영향을 최소화할 수 있습니다. 이로써 모듈화와 재사용성이 증가하며 코드의 유지보수가 쉬워집니다.
  2) 테스트 용이성: 레이어 간의 분리로 인해 단위 테스트, 통합 테스트 등이 각 레이어에 대해 독립적으로 수행될 수 있습니다. 이는 테스트의 용이성을 높여 소프트웨어의 품질을 향상시킵니다.
  3) 확장성: 각 레이어가 독립적으로 존재하므로, 특정 레이어의 변경 없이 새로운 기능을 추가하거나 기존 기능을 확장하는 것이 상대적으로 쉽습니다.  
 
- 단점
- 1) 성능 오버헤드: 레이어 간의 통신으로 인해 성능에 일부 오버헤드가 발생할 수 있습니다. 특히 많은 양의 데이터를 주고받아야 하는 경우, 이는 성능 저하로 이어질 수 있습니다.
  2) 복잡성 증가: 각 레이어가 독립적으로 관리되기 때문에, 레이어 간의 상호작용과 데이터 전달 등이 복잡해질 수 있습니다. 이는 프로젝트의 초기 단계에서는 장점이 될 수 있으나, 시스템이 커지면서 복잡성이 증가할 수 있습니다.
  3) 초기 설정 및 학습 곡선: 초기에는 레이어 간의 구분과 통신 방법 등을 정의하는 것이 필요하며, 팀 멤버들이 해당 아키텍처에 익숙해지는 데 시간이 걸릴 수 있습니다.  

4. **숙련주차 과제에서 Mongoose를 Sequelize로 교체 했을 때와 비교하여 이번 과제에서 Sequelize를 Prisma로 교체하는 작업은 더 쉬웠나요? 더 어려웠나요? 왜 그런지 3-Layered Architecture를 기반으로 설명해 주세요.**
- 3-Layered Architecture 관점에서는 데이터 액세스 레이어의 교체 작업이 프로젝트 전체에 미치는 영향을 고려해야 하는데 Prisma는 GraphQL에 기반한 ORM으로, 데이터 모델이나 스키마의 정의가 간편합니다. 그러므로 Sequelize에서 Prisma로의 교체는 데이터베이스 종류에 따른 쿼리 언어 변화보다는 비교적 쉽게 작업할 수 있었습니다.  

5. **테스트코드 작성의 장점과 단점을 아는대로 적어주세요.**
- 장점
- 1) 버그 식별 및 예방: 테스트코드를 작성하면 프로그램의 버그를 더 쉽게 식별할 수 있습니다. 또한, 새로운 기능 추가나 기존 기능 수정 시에도 테스트를 통해 예상치 못한 버그를 방지할 수 있습니다.
  2) 유지보수 용이성: 테스트코드를 작성하면 코드를 이해하고 유지보수하는 데 도움이 됩니다. 새로운 개발자가 코드를 이해하거나, 기존 코드를 수정할 때 안정성을 유지하기 쉬워집니다.
  3) 리팩토링 지원: 코드 리팩토링 시에도 테스트코드는 안정성을 보장하면서 변경 사항을 확인할 수 있는 중요한 자산입니다. 리팩토링 후에도 기능이 여전히 기대대로 동작하는지 확인할 수 있습니다.
  4) 개발 속도 향상: 테스트코드를 통해 버그를 미리 발견하고 수정하면 개발 속도가 향상됩니다. 디버깅에 들어가는 시간이 줄어들어 더 효율적으로 작업할 수 있습니다.  

- 단점
- 1) 시간과 비용: 테스트코드를 작성하는 데 시간과 비용이 들어갑니다. 특히, 초기에는 개발 속도가 느려질 수 있습니다. 그러나 장기적으로는 이 비용이 효과적으로 감소하고 유지보수 비용을 줄일 수 있습니다.
  2) 완전한 테스트가 어려움: 모든 상황을 완전히 테스트하는 것은 어려울 수 있습니다. 모든 테스트 케이스를 고려하기 어려운 경우가 있을 수 있으며, 이로 인해 몇몇 버그를 놓치게 될 수 있습니다.
  3) 불필요한 테스트 작성: 모든 코드에 대한 테스트를 작성하려고 하면 불필요하게 테스트 코드를 작성하게 되는 경우가 발생할 수 있습니다. 특히, 간단한 기능에 대한 테스트를 지나치게 작성하는 경우가 있습니다.
  4) 변경에 민감함: 코드의 구조가 변경되면 테스트 코드도 함께 수정해야 합니다. 이는 리팩토링 시에 추가적인 작업을 필요로 하게 됩니다.  
 
6. **테스트의 종류 3가지와 각각이 무엇인지 간단히 설명해 주세요.**
- 단위 테스트 : 단위 테스트는 매우 낮은 수준이며 애플리케이션의 소스와 가깝습니다. 소프트웨어에서 사용하는 클래스, 구성 요소 또는 모듈의 개별 메서드와 함수를 테스트하는 것으로 구성되어 있습니다. 단위 테스트는 일반적으로 자동화 비용이 상당히 저렴하며 지속적 통합 서버에서 매우 빠르게 실행할 수 있습니다.
- 통합 테스트 : 통합 테스트는 애플리케이션에 사용되는 여러 모듈 또는 서비스가 잘 작동하는지 확인합니다. 예를 들어, 데이터베이스와의 상호 작용을 테스트하거나 마이크로서비스가 예상대로 함께 작동하는지 확인하는 것일 수 있습니다. 이러한 유형의 테스트는 애플리케이션의 여러 부분을 실행해야 하기 때문에 실행 비용이 더 많이 듭니다.
- 기능 테스트 : 기능 테스트는 애플리케이션의 비즈니스 요구 사항에 초점을 맞춥니다. 이 테스트는 작업의 출력만 확인하며 작업을 수행할 때 시스템의 중간 상태는 확인하지 않습니다.  

통합 테스트와 기능 테스트는 모두 서로와 상호 작용하는 데 여러 구성 요소가 필요하기 때문에 둘 사이를 헷갈리는 경우가 있습니다. 차이점은 통합 테스트의 경우 단순히 데이터베이스를 쿼리할 수 있는지 확인하는 반면 기능 테스트의 경우 제품 요구 사항에 정의된 대로 데이터베이스에서 특정 값을 받을 것으로 예상합니다.
